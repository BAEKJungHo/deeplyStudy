# 쿠키

- Set-Cookie: 서버에서 클라이언트로 쿠키 전달(응답)
- Cookie: 클라이언트가 서버에서 받은 쿠키를 저장하고, HTTP 요청시 서버로 전달

쿠키에는 영속 쿠키와 세션 쿠키가 있다.

- 영속 쿠키: 만료 날짜를 입력하면 해당 날짜까지 유지
  - `expires` 가 만료 되면 쿠키는 즉시 종료된다.
- 세션 쿠키: 만료 날짜를 생략하면 브라우저 종료시 까지만 유지
  - `max-age` 를 0으로 설정하면 해당 쿠키는 즉시 종료된다.
로그인 기능 구현 시에는 `세션 쿠키`를 사용한다. 로그인에 성공하면 쿠키를 생성하고 HttpServletResponse 에 담는다. 

- Secure
  - 쿠키는 http, https를 구분하지 않고 전송
  - Secure를 적용하면 https인 경우에만 전송
- HttpOnly
  - XSS 공격 방지
  - 자바스크립트에서 접근 불가(document.cookie)
  - HTTP 전송에만 사용
- SameSite
  - XSRF 공격 방지
  - 요청 도메인과 쿠키에 설정된 도메인이 같은 경우만 쿠키 전송

- 보안 문제
  - 쿠키 값은 임의로 변경할 수 있다.
    - 클라이언트가 쿠키를 강제로 변경하면 다른 사용자가 된다.
    - 실제 웹브라우저 개발자모드 `Application Cookie` 변경으로 확인
    - Cookie: memberId=1 Cookie: memberId=2 (다른 사용자의 이름이 보임)
  - 쿠키에 보관된 정보는 훔쳐갈 수 있다.
    - 만약 쿠키에 개인정보나, 신용카드 정보가 있다면?
    - 이 정보가 웹 브라우저에도 보관되고, 네트워크 요청마다 계속 클라이언트에서 서버로 전달된다.
    - 쿠키의 정보가 나의 로컬 PC가 털릴 수도 있고, 네트워크 전송 구간에서 털릴 수도 있다.
  - 해커가 쿠키를 한번 훔쳐가면 평생 사용할 수 있다.
    - 해커가 쿠키를 훔쳐가서 그 쿠키로 악의적인 요청을 계속 시도할 수 있다.

- 대안
  - 쿠키에 중요한 값을 노출하지 않고, `사용자 별로 예측 불가능한 임의의 토큰(랜덤 값)을 노출`하고, 서버에서 토큰과 사용자 id 를 매핑해서 인식한다. 그리고 서버에서 토큰을 관리한다.
  - 토큰은 해커가 임의의 값을 넣어도 찾을 수 없도록 예상 불가능 해야 한다.
  - 해커가 토큰을 털어가도 시간이 지나면 사용할 수 없도록 서버에서 해당 토큰의 만료시간을 짧게(Ex. 30분) 유지한다. 또는 해킹이 의심되는 경우 서버에서 해당 토큰을 강제로 제거하면 된다.

# 세션

사실 세션이라는 것이 뭔가 특별한 것이 아니라 단지 쿠키를 사용하는데, 서버에서 데이터를 유지하는 방법일 뿐이다.

## 세션으로 로그인 기능 

- 세션 생성과 조회
  - 세션을 생성하려면 request.getSession(true) 를 사용하면 된다.
  - `public HttpSession getSession(boolean create);`

- request.getSession(true)
  - 세션이 있으면 기존 세션을 반환한다.
  - 세션이 없으면 새로운 세션을 생성해서 반환한다.
- request.getSession(false)
  - 세션이 있으면 기존 세션을 반환한다.
  - 세션이 없으면 새로운 세션을 생성하지 않는다. null 을 반환한다.
- request.getSession() : 신규 세션을 생성하는 request.getSession(true) 와 동일하다.

따라서, 위 개념을 적용하여 로그인 기능을 구현하면 아래와 같은 코드가 나온다.

```java
// 세션이 없으면 home
HttpSession session = request.getSession(false);
if (session == null) {
  return "home";
}

Member loginMember = (Member)session.getAttribute(SessionConst.LOGIN_MEMBER);
// 세션에 회원 데이터가 없으면 home
if (loginMember == null) {
  return "home";
}
```

스프링에서는 `@SessionAttribute` 라는 어노테이션을 이용하여 더 편리하게 쓸 수 있다.

- `@SessionAttribute`
  - 스프링은 세션을 더 편리하게 사용할 수 있도록 @SessionAttribute 을 지원한다.

이미 로그인 된 사용자를 찾을 때는 다음과 같이 사용하면 된다. 참고로 이 기능은 세션을 생성하지 않는다.

`@SessionAttribute(name = "loginMember", required = false) Member loginMember`

```java
 public String homeLoginV3Spring(
    @SessionAttribute(name = SessionConst.LOGIN_MEMBER, required = false) Member loginMember,
    Model model
 ) {
    // 세션에 회원 데이터가 없으면 home
    if (loginMember == null) {
        return "home";
    }

    // 세션이 유지되면 로그인으로 이동
    model.addAttribute("member", loginMember);
    return "loginHome";
}
```

세션을 찾고, 세션에 들어있는 데이터를 찾는 번거로운 과정을 스프링이 한번에 편리하게 처리해주는 것을 확인할 수 있다.

## 첫 로그인 시 jsessionid 가 URL 에 붙는 이유

서버 입장에서 웹 브라우저가 쿠키를 지원하는지 하지 않는지 최초에는 판단하지 못하므로, 쿠키 값도 전달하고, URL 에 `jessionid` 도 함께 전달한다.

URL 에 jessionid 를 붙여 전달하는 방식을 `URL 전달 방식`이라고 하는데, 이것은 웹 브라우저가 쿠키를 지원하지 않을 때 사용하는 방식이다.

URL 전달 방식을 끄고 항상 쿠키를 통해서만 세션을 유지하고 싶으면 스프링의 경우 `tracking-modes` 를 추가해주면 된다.

- application.properties

```yml
server.servlet.session.tracking-modes=cookie
```

## 세션 타임 아웃

세션은 사용자가 로그아웃을 직접 호출해서 `session.invalidate()` 가 호출 되는 경우에 삭제된다. 
그런데 대부분의 사용자는 로그아웃을 선택하지 않고, 그냥 웹 브라우저를 종료한다. 문제는 HTTP가 `비연결성(ConnectionLess)`이므로 서버 입장에서는 해당 사용자가 웹 브라우저를 종료한 것인지 아닌지를 인식할 수 없다. 따라서 서버에서 세션 데이터를 언제 삭제해야 하는지 판단하기가 어렵다.

이 경우 남아있는 세션을 무한정 보관하면 다음과 같은 문제가 발생할 수 있다.

- 세션과 관련된 쿠키(JSESSIONID)를 탈취 당했을 경우 오랜 시간이 지나도 해당 쿠키로 악의적인 요청을 할 수 있다.
- 세션은 기본적으로 메모리에 생성된다. 메모리의 크기가 무한하지 않기 때문에 꼭 필요한 경우만 생성해서 사용해야 한다. 10만명의 사용자가 로그인하면 10만개의 세션이 생성되는 것이다.

### 세션의 종료 시점

세션의 종료 시점을 어떻게 정하면 좋을까? 가장 단순하게 생각해보면, 세션 생성 시점으로부터 30분
정도로 잡으면 될 것 같다. 그런데 문제는 30분이 지나면 세션이 삭제되기 때문에, 열심히 사이트를
돌아다니다가 또 로그인을 해서 세션을 생성해야 한다 그러니까 30분 마다 계속 로그인해야 하는
번거로움이 발생한다.

더 나은 대안은 세션 생성 시점이 아니라 `사용자가 서버에 최근에 요청한 시간을 기준`으로 30분 정도를 유지해주는 것이다. 

이렇게 하면 사용자가 서비스를 사용하고 있으면, 세션의 생존 시간이 30분으로 계속
늘어나게 된다. 따라서 30분 마다 로그인해야 하는 번거로움이 사라진다. 

HttpSession 은 이 방식을 사용한다.

### 세션 타임아웃 설정

- 세션 타임아웃 설정 우선 순위는 다음과 같다.
  1. 코드 레벨 설정
  2. 글로벌 설정
  3. web.xml 설정
  4. WAS 서버 설정

- 특정 세션 단위로 설정(코드 레벨 설정)

```java
session.setMaxInactiveInterval(1800); //1800초
```

- 글로벌 설정 방법

```yml
server.servlet.session.timeout=60 // 분 단위로 설정해야 한다.
```

### 세션 타임아웃 발생

세션의 타임아웃 시간은 해당 세션과 관련된 JSESSIONID 를 전달하는 HTTP 요청이 있으면 현재 시간으로
다시 초기화 된다. 이렇게 초기화 되면 세션 타임아웃으로 설정한 시간동안 세션을 추가로 사용할 수 있다.

session.getLastAccessedTime() : 최근 세션 접근 시간

LastAccessedTime 이후로 timeout 시간이 지나면, WAS가 내부에서 해당 세션을 제거한다.

> `보관한 데이터 용량 * 사용자` 수로 세션의 메모리 사용량이 급격하게 늘어나서 장애로 이어질 수 있다. 추가로 세션의 시간을 너무 길게
가져가면 메모리 사용이 계속 누적 될 수 있으므로 적당한 시간을 선택하는 것이 필요하다. 기본이 30
분이라는 것을 기준으로 고민하면 된다.

# 쿠키와 세션 사용 시 주의 점

__클라이언트와 서버는 결국 쿠키로 연결이 되어야 한다.__

- 쿠키는 웹 브라우저에서 쉽게 정보를 변경할 수 있어서, 클라이언트 해킹 시 정보가 쉽게 노출될 수 있기 때문에 중요한 정보를 담아서는 안 된다.
- 세션은 정보를 서버에 저장하고 클라이언트에는 JSESSIONID 라는 쿠키 값만 넘겨 사용하기 때문에 쿠키만 사용했을 때보다는 안전 하지만, 그래도 세션에 정보를 담을 때, 중요한 정보는 암호화해서 담아야한다. `세션 하이재킹`이라는 기술이 있기 때문에 세션도 해킹 당할 수 있다.
  - 세션에는 가급적 필요한 정보들만 추려서 담아야 한다.
  - 세션에 담긴 객체를 꺼내어 그 객체의 값을 변경 시킨다던지의 행동은 하지 말아야 한다.

- 세션에 담긴 객체 꺼내서 값 변경 금지

```java
HttpSession session = request.getSession(false); // 세션을 찾아서 사용하는 시점에는 false 를 주어서 세션을 생성하지 않아야 한다.
LoginUser user = (LoginUser) session.getAttribute(LOGIN_SESSION_ID);
user.setId("abc"); // 바꾸는 순간 세션에 들어있는 로그인 아이디가 변경 된다. 따라서 이러한 코드는 짜지 말아야 한다.
```

# 자동 로그인 구현 방법

스프링 시큐리티의 `remember-me` 는 자동 로그인을 구현할 수 있게 해주는데, 특징은 `세션과 쿠키`를 이용한다는 것이다.

세션은 브라우저 소멸시 같이 소멸되기 때문에, 자동 로그인을 구현하기 위해서는 쿠키를 이용해서 유효기간을 설정해줘야 한다.

로그인에 성공했을 때 사용자 DB 테이블에 sessionId 와 유효기간 컬럼에 값을 지정하는 것이다. 그리고 쿠키에는 sessionId 를 넣어 놓는다.

그리고 인터셉터(interceptor) 에서 해당 쿠키값이 존재하면 사용자 DB 테이블 내에서 유효시간 > now() 즉, 유효시간이 아직 남아 있으면서 해당 세션 Id를 가지고 있는 사용자 정보를 검색해 해당 사용자 객체를 반환하는 것이다.

이후, AuthenticationInterceptor의 preHandle() 부분에서

세션에 UserVO 객체가 null 이 아닌 경우는 로그인 되어 있는 부분이니까 그대로 처리되도록 놔두고, 세션의 UserVO 객체가 null 이지만, 쿠키가 null 이 아닌 경우 쿠키에서 sessionId 를 꺼내와서 사용자 객체를 반환받도록 작업해야한다.

인터셉터랑, 로그인 처리하는 컨트롤러 부분에서는 로그인 하고 나면 최종 접속일을 수정해야한다.
